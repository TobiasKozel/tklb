#ifndef TKLB_BUS
#define TKLB_BUS

#include "./TPointerList.h"
#include "./TMutex.h"
#include "../util/TAssert.h"
#include <functional>

namespace tklb {
	/**
	 * Simple Message bus system
	 */
	class Bus {
	public:
		using Event = unsigned int;

	private:
		/**
		 * Base class of all subscription classes
		 * generated by templating
		 */
		class SubBase {
		protected:
			Event mEvent = 0;
			Bus* mBus = nullptr;
		public:
			virtual ~SubBase() { };
			Event getEvent() const {
				return mEvent;
			}
		};

		using SubsVector = PointerList<SubBase>;
		SubsVector* mSubscriptions = nullptr;
		Mutex mMutex;
		unsigned int mSubCount = 0;
		Event mEventCount = 0;

	public:
		Bus(unsigned int eventCount) {
			mEventCount = eventCount;
			mSubscriptions = new SubsVector[eventCount];
		}

		~Bus() {
			for (int i = 0; i < mEventCount; i++) {
				mSubscriptions[i].clear();
			}
			delete[] mSubscriptions;
		}

		void add(SubBase* sub) {
			const Event event = sub->getEvent();
			if (event > mEventCount) { return; }
			LockGuard lock(mMutex);
			mSubscriptions[event].add(sub);
			mSubCount++;
		}

		void remove(SubBase* sub) {
			const Event event = sub->getEvent();
			if (mSubCount > 0) {
				LockGuard lock(mMutex);
				if (mSubscriptions[event].remove(sub)) {
					mSubCount--;
				}
			}
		}

		template <class T>
		/**
		 * The derived Subscriber
		 * T is the type of data the callback gets passed
		 */
		class Sub : public SubBase {
			using Callback = std::function<void(T param)>;
			Callback mCallback;
		public:
			Sub() { }

			Sub(Bus& bus, const Event event, Callback callback) {
				subscribe(&bus, event, callback);
			}

			Sub(Bus* bus, const Event event, Callback callback) {
				subscribe(bus, event, callback);
			}

			~Sub() {
				if (mBus == nullptr) { return; }
				mBus->remove(this);
			}

			void subscribe(Bus* bus, const Event event, Callback callback) {
				if (mBus != nullptr) { return; }
				mBus = bus;
				mEvent = event;
				mCallback = callback;
				bus->add(this);
			}

			void call(T& param) const {
				mCallback(param);
			}
		};

		template <class T2>
		void fire(const Event event, T2 param) {
			TKLB_ASSERT(event < mEventCount);
			SubsVector& subs = mSubscriptions[event];
			if (subs.size() == 0) { return; }
			LockGuard lock(mMutex);
			for (unsigned int i = 0; i < subs.size(); i++) {
				Sub<T2>* sub = dynamic_cast<Sub<T2>*>(subs[i]);
				if (sub != nullptr) {
					sub->call(param);
				}
			}
		}
	};

} // namespace

#endif // TKLB_BUS
